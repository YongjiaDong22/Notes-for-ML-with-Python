# 无监督学习-聚类

## 一、K-均值（K-means）聚类算法

### 1. 介绍

以k为参数，把n个对象分成k个簇，使簇内具有较高的相似度，而簇间的相似度较低。

### 2. 步骤

+ 随机选择k个点作为**初始**的聚类中心
+ 对于剩下的点，根据其与聚类中心的距离，将其归入**最近**的簇
+ 对每个簇，计算所有点的**均值**作为新的聚类中心
+ 重复2和3，直到**聚类中心**不再发生改变

### 3. 图解

### 4. 应用（31个省份的消费性支出）

目的：了解1999年各个省份的消费水平在国内的情况。

思路：**sklearn.cluster.KMeans**

过程：

+ 建立工程，导入sklearn相关包
+ 加载数据，创建K-means算法实例，并进行训练，获得标签
+ 输出标签，查看结构

注意：

（1）调用K-Means方法所需参数

+ n_clusters：指定聚类中心的个数
+ init：初始聚类中心的初始化方法
+ max_iter：最大的迭代次数，即K-Means方法的最大迭代次数

***一般调用时只用给出n_clusters即可，init默认是k-means++，max_iter默认是300***

+ data：加载的数据
+ label：聚类后各数据所属的标签
+ fit_predict()：计算簇中心以及为簇分配序号

（2）自建loadData函数，用于加载数据

代码：

```
### 建立工程
#导入numpy
import numpy as np
#导入KMeans
from sklearn.cluster import KMeans

### loadData
def loadData(filePath):
    #以读写的方式打开文件
    fr = open(filePath,'r+',encoding='gbk')
    #一次读取整个文件
    lines = fr.readlines()
    #存储城市的各项消费信息
    retData = []
    #存储城市名称
    retCityName = []
    for line in lines:
        items = line.strip().split(",")
        retCityName.append(items[0])
        retData.append([float(items[i]) for i in range(1,len(items))])
    #返回值为retData和retCityName
    return retData,retCityName
 
if __name__ == '__main__':
### 加载数据
    #利用loadData方法读取数据
    data,cityName = loadData('city.txt')
    #创建实例，n_clusters指定聚类中心的个数
    km = KMeans(n_clusters=4)
    #调用Kmeans()和fit_predict()方法进行聚类计算
    label = km.fit_predict(data)
    expenses = np.sum(km.cluster_centers_,axis=1)
###展示结果
    CityCluster = [[],[],[],[]]
    #将城市按label分成设定的簇
    for i in range(len(cityName)):
        CityCluster[label[i]].append(cityName[i])
    #将每个簇的城市和消费输出
    for i in range(len(CityCluster)):
        #其中expense是聚类中心的数值加和，也就是平均消费水平
        print("Expenses:%.2f" % expenses[i])
        print(CityCluster[i])
```

其他知识点：

（1）Python的输出格式中，%d表示普通整数输出，如22；%4d表示宽度为4的整数输出，如0022；%.2f表示保留小数点后2位，如22.22。

（2）Sklearn的K-Means默认用的是**欧式距离**，没有设定计算距离方法的参数。如果想要自定义计算距离的方式，可以更改pairwise.py源代码，建议使用scipy.spatial.distance.cdist方法。
